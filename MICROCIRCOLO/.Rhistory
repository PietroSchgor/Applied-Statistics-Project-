xy1 <- xyplot(Hb ~ `dose alla fraz mim`,
groups = paz,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "dose",
ylab = "var Hb",
grid = "h")
xy1 <- xyplot(Hb ~ meas,
groups = paz,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "misurazione",
ylab = "var Hb",
grid = "h")
# rimozione dello stato iniziale
dataset <- dataset[-which(dataset$`dose alla fraz mim` == 0), ]
dim(dataset)
# rimozione dei valori di hb_base <1
dataset <- dataset[-which(dataset$`Hb base` < 1), ]
dim(dataset)
#variazione con segno di Hb, ossia traslo di 100 in negativo
dataset$Hb <- dataset$Hb - 100
# controllo NA
any(is.na(dataset))
colSums(is.na(dataset))
#LMM
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^2
x2 <- dataset$`Hb base`
dataset$Name <- as.factor (dataset$Name)
eps <- dataset$paz
meas <- dataset$meas
mod <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
sigma2_eps <- as.numeric(get_variance_residual(mod))
sigma2_eps
sigma2_b <- as.numeric(get_variance_random(mod))
sigma2_b
PVRE <- sigma2_b/(sigma2_b+sigma2_eps)
PVRE # very high PVRE!!!
summary(mod)
residui <- resid(mod)
mse <- mean(residui^2)
sqrt(mse)
#Devo controllare omoschedasticità
library(ggplot2)
ggplot(data.frame(predetti = predict(mod), residui = residui), aes(x = predetti, y = residui)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(x = "Valori Predetti", y = "Residui") +
ggtitle("Grafico dei Residui per Valutare l'Omoschedasticità")
######PROVO ALTRE POTENZE
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
mod2 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod2)
residui2 <- resid(mod2)
mse2 <- mean(residui2^2)
sqrt(mse2)
x1 <- dataset$`dose alla fraz mim`
mod3 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod3)
residui3 <- resid(mod3)
mse3 <- mean(residui3^2)
sqrt(mse3)
x1 <- (dataset$`dose alla fraz mim`)^(3/2)
mod4 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod4)
residui4 <- resid(mod4)
mse4 <- mean(residui4^2)
sqrt(mse4)
#PROVO con prodotto misto
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod5 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod5)
residui5<- resid(mod5)
mse5 <- mean(residui5^2)
sqrt(mse5)
AIC_model1 <- AIC(mod)
AIC_model2 <- AIC(mod2)
AIC_model3 <- AIC(mod3)
AIC_model4 <- AIC(mod4)
AIC_model5 <- AIC(mod5)
# Akaike tiene conto della massima vcerosimiglianza e del numero dei parametri
#−2×log-verosimiglianza massima+2×numero di parametri del modello
print(AIC_model1)
print(AIC_model2)
print(AIC_model3)
print(AIC_model4)
print(AIC_model5) #migliore(se lascio la dose lineare migliora mse ma peggiora AIC (di pochissimo))
if (AIC_model1 < AIC_model2 && AIC_model1 < AIC_model3) {
print("Il primo modello è il migliore.")
} else if (AIC_model2 < AIC_model3){
print("Il secondo modello è il migliore.")
} else {
print("Il terzo modello è il migliore")
}
##residui eteroschedastici---------
library(nlmeU)
library(corrplot)
library(nlme)
library(lattice)
library(plot.matrix)
library(lme4)
library(insight)
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod6 <- lme(y ~ x1 + x2,
random = ~ 1 + meas| eps,
data = dataset)
summary(mod6)
residui <- resid(mod6)
mse <- mean(residui^2)
sqrt(mse)
mod7 <- update(mod6,
weights = varIdent(form = ~ meas),
data = dataset)
summary(mod7)
residui7<- resid(mod7)
mse7 <- mean(residui7^2)
sqrt(mse7)
AIC_model7<-AIC(mod7)
mod8<- update(mod6,
weights = varPower(form = ~ meas),
data = dataset)
summary(mod8)
library(readxl)
#### DATASET ####
data_micro1 <- read_excel("dataset_microcircolo.xlsx")
library(readxl)
#### DATASET ####
data_micro1 <- read_excel("dataset_microcircolo.xlsx")
setwd("C:/Users/alber/Downloads/MICROCIRCOLO/MICROCIRCOLO")
library(readxl)
#### DATASET ####
data_micro1 <- read_excel("dataset_microcircolo.xlsx")
dim(data_micro1)
str(data_micro1)
data_micro2 <- read_excel("dataset_microcircolo.xlsx",sheet ="2mis_h&n")
dim(data_micro2)
data_micro3 <- read_excel("dataset_microcircolo.xlsx",sheet ="3mis_h&n")
dim(data_micro3)
data_micro4 <- read_excel("dataset_microcircolo.xlsx",sheet ="4mis_h&n")
dim(data_micro4)
data_micro5 <- read_excel("dataset_microcircolo.xlsx",sheet ="5mis_h&n")
dim(data_micro5)
data_micro6 <- read_excel("dataset_microcircolo.xlsx",sheet ="6mis_h&n")
dim(data_micro6)
data_micro7 <- read_excel("dataset_microcircolo.xlsx",sheet ="7mis_h&n")
dim(data_micro7)
# seleziono le colonne che possono essere utili per adesso
library(dplyr)
data_micro1 <-   data_micro1 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
data_micro2 <- data_micro2 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
data_micro3 <- data_micro3 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
data_micro4 <- data_micro4 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
data_micro5 <- data_micro5 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
data_micro6 <- data_micro6 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
data_micro7 <- data_micro7 %>%
select(Name, `N MEASURE`, Status, TimePeriods, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
# unisco il dataset
data <- rbind( data_micro1, data_micro2, data_micro3, data_micro4,
data_micro5, data_micro6, data_micro7 )
microctot <- data %>%
select(Name, `N MEASURE`, Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
#rimozione  NA
microctot <- na.omit(microctot)
dim(microctot)
microc <- microctot %>%
select( Flow, `Total density`, CBV_abs,
CBV_rel, CBV_RC, `CBV-dyn`, `PBR4-25`)
library(GGally)
ggpairs(microc)
boxplot(scale(x = microc, center = T, scale = F), las = 2, col = 'gold')
pc.microc <- princomp(microc, scores = T)
pc.microc
summary(pc.microc)
# To obtain the rows of the summary:
# Standard deviation of the components
pc.microc$sd
# Proportion of variance explained by each PC
pc.microc$sd^2 / sum(pc.microc$sd^2)
# Cumulative proportion of explained variance
cumsum(pc.microc$sd^2) / sum(pc.microc$sd^2)
# Get loadings (coefficients of the linear combination of the original variables that defines each
# principal component)
load.tour <- pc.microc$loadings
load.tour # P matrix (matrice diagonalizzante della matrice varianza)
load.tour[, 1:7]
# graphical representation of the loadings of the first three principal components
par(mfrow = c(3,1))
for(i in 1:3) barplot(load.tour[,i], ylim = c(-0.5, 0.5))
layout(matrix(c(2, 3, 1, 3), 2, byrow = TRUE))
# Variance explained by the principal components
plot(pc.microc, las = 2, main = 'Principal components', ylim = c(0, 1.7e5))
# Variances of original variables
barplot(sapply(microc, sd)^2, las = 2, main = 'Original Variables', ylim = c(0, 1.7e5),
ylab = 'Variances')
# Plot contribution to the total variance by number of components
plot(cumsum(pc.microc$sd^2) / sum(pc.microc$sd^2), type = 'b', axes = FALSE,
xlab = 'Number of components', ylab = 'Contribution to the total variance', ylim = c(0, 1))
abline(h = 1, col = 'blue')
abline(h = 0.8, lty = 2, col = 'blue')
box()
axis(2, at = 0:10/10, labels = 0:10/10)
axis(1, at = 1:ncol(microc), labels = 1:ncol(microc), las = 2)
## PCA on the standardized variables ----------------------------------------------------------
microc.sd <- scale(microc)
microc.sd <- data.frame(microc.sd)
head(microc.sd)
# Boxplot
par(mfrow = c(1, 1))
boxplot(microc.sd, las = 2, col = 'gold')
pc.microc <- princomp(microc.sd, scores = T)
pc.microc
summary(pc.microc)
layout(matrix(c(2, 3, 1, 3), 2, byrow = TRUE))
# Variance explained by the principal components
plot(pc.microc, las = 2, main = 'Principal Components', ylim = c(0, 7))
abline(h = 1, col = 'blue')
# Variances of original variables
barplot(sapply(microc.sd, sd)^2, las = 2, main = 'Original Variables', ylim = c(0, 7),
ylab = 'Variances')
abline(h = 1, col = 'blue')
# Plot contribution to the total variance by number of components
plot(cumsum(pc.microc$sde^2) / sum(pc.microc$sde^2), type = 'b', axes = FALSE,
xlab = 'Number of components', ylab = 'Contribution to the total variance', ylim = c(0, 1))
abline(h = 1, col = 'blue')
abline(h = 0.8, lty = 2, col = 'blue')
box()
axis(2, at = 0:10/10, labels = 0:10/10)
axis(1, at = 1:ncol(microc.sd), labels = 1:ncol(microc.sd), las = 2)
load.tour <- pc.microc$loadings
load.tour
# Graphical representation
par(mar = c(2,2,2,1), mfrow=c(3,1))
for(i in 1:3){barplot(load.tour[,i], ylim = c(-1, 1), main=paste('Loadings PC ',i,sep=''))
abline(h = 0, col = 'blue')}
## Scores -------------------------------------------------------------------------------------
scores.microc <- pc.microc$scores
scores.microc
# Scatter plot of the scores
par(mfrow = c(1,1))
plot(scores.microc[, 1:2])
abline(h=0, v=0, lty=2, col='grey')
# Biplot
par(mfrow = c(1, 1))
biplot(pc.microc)
# Let's use the CATEGORICAL variables to further interpret the results
head(microc.label)
microc.label<- microctot %>%
select(,1:2)
microc.label<-data.frame(microc.label)
head(microc.label)
meas<- c(" #01 Measurement", " #02 Measurement", " #03 Measurement", " #04 Measurement", " #05 Measurement", " #06 Measurement", " #07 Measurement")
microc.label[, 2] <- factor(microc.label[ ,2])
microc.label[, 2]
meas<-levels(microc.label[, 2])
# Define a cyclic palette
colors <- c("#2D1857", "#6C47C7", "#7A8CDD", "#68B5C5",
"#108963", "#025A26", "#013814")
colors <- c("grey", "yellow", "orange", "red",
"brown", "black", "black")
n<-dim(scores.microc)[1]
col.lab1 <- rep(NA, n)
for(i in 1:n)
col.lab1[i] <- colors[which(microc.label[i, 2] == levels(microc.label[, 2]))]
col.lab1
plot(scores.microc[, 1:2], col = col.lab1, pch = 19, xlim = c(-8, 25), ylim = c(-3, 3.2), xlab='I principal component', ylab='II principal component')
abline(h = -3, v = -8, col = 1)
points(scores.microc[, 1], rep(-3, n), col = col.lab1, pch = 19)
points(rep(-8, n), scores.microc[, 2], col = col.lab1, pch = 19)
abline(h = 0, v = 0, lty = 2, col = 'grey')
legend('topright', levels(factor(microc.label[, 2])), fill = colors, bty = 'n')
#SPLITTO VARIABILI IN BASE A SCORE POSITIVO/NEGATIVO NEL I PRINCIPAL COMPONENT
#FLOW, TOT-DENSITY, CBV_ABS
microc.sd <- scale(microc)
microc.sd <- data.frame(microc.sd)
microc.sd<-microc.sd %>%
select(Flow,Total.density,CBV_abs)
head(microc.sd)
# Boxplot
par(mfrow = c(1, 1))
boxplot(microc.sd, las = 2, col = 'gold')
#aggiungo pezzo prova
library(rgl)
options(rgl.printRglwidget = TRUE)
nobs <- 92
X <- microc.sd
# sample mean and covariance matrix
M <- colMeans(X)
M
S <- cov(X)
points3d(X, asp=1, size=4)  # plot the points
axes3d()                    # add the axes
plot3d(ellipse3d(S, centre=M, level= 9/10), alpha=0.15, add=TRUE) # add the ellipsoid
# Principal components
PC <- princomp(X)
summary(PC)
# "0" principal component: the best approximation of dimension 0 (a point)
open3d()
points3d(X, asp=1, size=4)
axes3d()
points3d(t(M), col='red', size=6)
for(i in 1:100)
lines3d(rbind(X[i,], M))
## Space spanned by the first PC --------------------------------------------------------------
# I principal component: the best approximation of dimension 1 (a line)
open3d()
points3d(X, asp=1, size=4)
axes3d()
PC1 <- NULL
for(i in 1:nobs) {
PC1 <- rbind(PC1, PC$loadings[,1]*PC$scores[i,1] + M)
}
points3d(PC1, col='red', size=6)
for(i in 1:nobs) {
lines3d(rbind(X[i,], PC1[i,]), col='blue')
}
lines3d(rbind(M + 2*PC$sdev[1] * PC$loadings[,1], M - 2*PC$sdev[1] * PC$loadings[,1]),
col='forestgreen',lwd=2)
## Space spanned by the first two PCs ----------------------------------------------------------
# I and II principal components: the best approximation of dimension 2 (a plane)
open3d()
points3d(X, asp=1, size=4)
axes3d()
PC12 <- NULL
for(i in 1:nobs) {
PC12 <- rbind(PC12, PC$loadings[,1]*PC$scores[i,1] + PC$loadings[,2]*PC$scores[i,2] + M)
}
points3d(PC12, col='red', size=6)
for(i in 1:nobs) {
lines3d(rbind(X[i,], PC12[i,]),col='blue')
}
lines3d(rbind(M + 2*PC$sdev[1] * PC$loadings[,1], M - 2*PC$sdev[1] * PC$loadings[,1]),
col='forestgreen',lwd=2)
lines3d(rbind(M + 2*PC$sdev[2] * PC$loadings[,2], M - 2*PC$sdev[2] * PC$loadings[,2]),
col='forestgreen',lwd=2)
pc.microc <- princomp(microc.sd, scores = T)
pc.microc
summary(pc.microc)
layout(matrix(c(2, 3, 1, 3), 2, byrow = TRUE))
# Variance explained by the principal components
plot(pc.microc, las = 2, main = 'Principal Components', ylim = c(0, 7))
abline(h = 1, col = 'blue')
# Variances of original variables
barplot(sapply(microc.sd, sd)^2, las = 2, main = 'Original Variables', ylim = c(0, 7),
ylab = 'Variances')
abline(h = 1, col = 'blue')
# Plot contribution to the total variance by number of components
plot(cumsum(pc.microc$sde^2) / sum(pc.microc$sde^2), type = 'b', axes = FALSE,
xlab = 'Number of components', ylab = 'Contribution to the total variance', ylim = c(0, 1))
abline(h = 1, col = 'blue')
abline(h = 0.8, lty = 2, col = 'blue')
box()
axis(2, at = 0:10/10, labels = 0:10/10)
axis(1, at = 1:ncol(microc.sd), labels = 1:ncol(microc.sd), las = 2)
load.tour <- pc.microc$loadings
load.tour
# Graphical representation
par(mar = c(2,2,2,1), mfrow=c(3,1))
for(i in 1:3){barplot(load.tour[,i], ylim = c(-1, 1), main=paste('Loadings PC ',i,sep=''))
abline(h = 0, col = 'blue')}
## Scores -------------------------------------------------------------------------------------
scores.microc <- pc.microc$scores
scores.microc
# Scatter plot of the scores
par(mfrow = c(1,1))
plot(scores.microc[, 1:2])
abline(h=0, v=0, lty=2, col='grey')
# Biplot
par(mfrow = c(1, 1))
biplot(pc.microc)
# Let's use the CATEGORICAL variables to further interpret the results
head(microc.label)
microc.label<- microctot %>%
select(,1:2)
microc.label<-data.frame(microc.label)
head(microc.label)
meas<- c(" #01 Measurement", " #02 Measurement", " #03 Measurement", " #04 Measurement", " #05 Measurement", " #06 Measurement", " #07 Measurement")
microc.label[, 2] <- factor(microc.label[ ,2])
microc.label[, 2]
meas<-levels(microc.label[, 2])
# Define a cyclic palette
colors <- c("#2D1857", "#6C47C7", "#7A8CDD", "#68B5C5",
"#108963", "#025A26", "#013814")
colors <- c("grey", "yellow", "orange", "red",
"brown", "black", "black")
n<-dim(scores.microc)[1]
col.lab1 <- rep(NA, n)
for(i in 1:n)
col.lab1[i] <- colors[which(microc.label[i, 2] == levels(microc.label[, 2]))]
col.lab1
plot(scores.microc[, 1:2], col = col.lab1, pch = 19, xlim = c(-8, 25), ylim = c(-3, 3.2), xlab='I principal component', ylab='II principal component')
abline(h = -3, v = -8, col = 1)
points(scores.microc[, 1], rep(-3, n), col = col.lab1, pch = 19)
points(rep(-8, n), scores.microc[, 2], col = col.lab1, pch = 19)
abline(h = 0, v = 0, lty = 2, col = 'grey')
legend('topright', levels(factor(microc.label[, 2])), fill = colors, bty = 'n')
#PCA with CBV_REL and CBV_RC
microc.sd <- scale(microc)
microc.sd <- data.frame(microc.sd)
microc.sd<-microc.sd %>%
select(CBV_rel,CBV_RC)
head(microc.sd)
# Boxplot
par(mfrow = c(1, 1))
boxplot(microc.sd, las = 2, col = 'gold')
pc.microc <- princomp(microc.sd, scores = T)
pc.microc
summary(pc.microc)
layout(matrix(c(2, 3, 1, 3), 2, byrow = TRUE))
# Variance explained by the principal components
plot(pc.microc, las = 2, main = 'Principal Components', ylim = c(0, 7))
abline(h = 1, col = 'blue')
# Variances of original variables
barplot(sapply(microc.sd, sd)^2, las = 2, main = 'Original Variables', ylim = c(0, 7),
ylab = 'Variances')
abline(h = 1, col = 'blue')
# Plot contribution to the total variance by number of components
plot(cumsum(pc.microc$sde^2) / sum(pc.microc$sde^2), type = 'b', axes = FALSE,
xlab = 'Number of components', ylab = 'Contribution to the total variance', ylim = c(0, 1))
abline(h = 1, col = 'blue')
abline(h = 0.8, lty = 2, col = 'blue')
box()
axis(2, at = 0:10/10, labels = 0:10/10)
axis(1, at = 1:ncol(microc.sd), labels = 1:ncol(microc.sd), las = 2)
load.tour <- pc.microc$loadings
load.tour
# Graphical representation
par(mar = c(2,2,2,1), mfrow=c(3,1))
for(i in 1:3){barplot(load.tour[,i], ylim = c(-1, 1), main=paste('Loadings PC ',i,sep=''))
abline(h = 0, col = 'blue')}
## Scores -------------------------------------------------------------------------------------
scores.microc <- pc.microc$scores
scores.microc
# Scatter plot of the scores
par(mfrow = c(1,1))
plot(scores.microc[, 1:2])
abline(h=0, v=0, lty=2, col='grey')
# Biplot
par(mfrow = c(1, 1))
biplot(pc.microc)
# Let's use the CATEGORICAL variables to further interpret the results
head(microc.label)
microc.label<- microctot %>%
select(,1:2)
microc.label<-data.frame(microc.label)
head(microc.label)
meas<- c(" #01 Measurement", " #02 Measurement", " #03 Measurement", " #04 Measurement", " #05 Measurement", " #06 Measurement", " #07 Measurement")
microc.label[, 2] <- factor(microc.label[ ,2])
microc.label[, 2]
meas<-levels(microc.label[, 2])
# Define a cyclic palette
colors <- c("#2D1857", "#6C47C7", "#7A8CDD", "#68B5C5",
"#108963", "#025A26", "#013814")
colors <- c("grey", "yellow", "orange", "red",
"brown", "black", "black")
n<-dim(scores.microc)[1]
col.lab1 <- rep(NA, n)
for(i in 1:n)
col.lab1[i] <- colors[which(microc.label[i, 2] == levels(microc.label[, 2]))]
col.lab1
plot(scores.microc[, 1:2], col = col.lab1, pch = 19, xlim = c(-8, 25), ylim = c(-3, 3.2), xlab='I principal component', ylab='II principal component')
abline(h = -3, v = -8, col = 1)
points(scores.microc[, 1], rep(-3, n), col = col.lab1, pch = 19)
points(rep(-8, n), scores.microc[, 2], col = col.lab1, pch = 19)
abline(h = 0, v = 0, lty = 2, col = 'grey')
legend('topright', levels(factor(microc.label[, 2])), fill = colors, bty = 'n')
#riempimento cbv_dyn
data_micro1$`CBV-dyn`[is.na(data_micro1$`CBV-dyn`)] <- data_micro1$CBV_abs[is.na(data_micro1$`CBV-dyn`)]*data_micro1$CBV_rel[is.na(data_micro1$`CBV-dyn`)]*(1+data_micro1$CBV_RC[is.na(data_micro1$`CBV-dyn`)])
#riempimento pbr4-25 : avg of pbr from 4 to 25  #equivalente a pbr stat
data_micro1$`PBR4-25`[is.na(data_micro1$`PBR4-25`)] <-(data_micro1$D4[is.na(data_micro1$`PBR4-25`)] + data_micro1$D5[is.na(data_micro1$`PBR4-25`)]+ data_micro1$D6[is.na(data_micro1$`PBR4-25`)]+data_micro1$D7[is.na(data_micro1$`PBR4-25`)]+data_micro1$D8[is.na(data_micro1$`PBR4-25`)]+data_micro1$D9[is.na(data_micro1$`PBR4-25`)]+data_micro1$D10[is.na(data_micro1$`PBR4-25`)]+data_micro1$D11[is.na(data_micro1$`PBR4-25`)]+data_micro1$D12[is.na(data_micro1$`PBR4-25`)]+data_micro1$D13[is.na(data_micro1$`PBR4-25`)]+data_micro1$D14[is.na(data_micro1$`PBR4-25`)]+data_micro1$D15[is.na(data_micro1$`PBR4-25`)]+data_micro1$D16[is.na(data_micro1$`PBR4-25`)]+ data_micro1$D17[is.na(data_micro1$`PBR4-25`)]+data_micro1$D18[is.na(data_micro1$`PBR4-25`)]+data_micro1$D19[is.na(data_micro1$`PBR4-25`)]+data_micro1$D20[is.na(data_micro1$`PBR4-25`)]+data_micro1$D21[is.na(data_micro1$`PBR4-25`)] +data_micro1$D22[is.na(data_micro1$`PBR4-25`)]+data_micro1$D23[is.na(data_micro1$`PBR4-25`)]+data_micro1$D24[is.na(data_micro1$`PBR4-25`)]+data_micro1$D25[is.na(data_micro1$`PBR4-25`)])/22
#riempimento mvhs_sta : cvbstat/ pbrstat = ( cvsass * cvb rel) / pbr stat
data_micro1$MVHS_STA[is.na(data_micro1$MVHS_STA)] <- (data_micro1$CBV_abs[is.na(data_micro1$MVHS_STA)]*data_micro1$CBV_rel[is.na(data_micro1$MVHS_STA)])/ data_micro1$`PBR4-25`[is.na(data_micro1$MVHS_STA)]
#riempimento mvhs_dyn: cbv dyn / pbr dyn
data_micro1$MVHS_dyn[is.na(data_micro1$MVHS_dyn)] <- data_micro1$`CBV-dyn`[is.na(data_micro1$MVHS_dyn)]/data_micro1$`PBR4-25 (flow corrected)`[is.na(data_micro1$MVHS_dyn)]
sum(is.na(data_micro1))
sum(is.na(data_micro1$CBV_abs))
sum(is.na(data_micro1$CBV_rel)) #stessi in cbv abs e cbv rel (e le altre variabili) -> va tolto il paziente
sum(is.na(data_micro1$`CBV-dyn`)) #31 na su 73, gli stessi di cbv rc
sum(is.na(data_micro1$CBV_RC))
sum(is.na(data_micro1$`PBR4-25`))
sum(is.na(data_micro1$`PBR4-25 (flow corrected)`))
sum(is.na(data_micro1$MVHS_STA))
sum(is.na(data_micro1$MVHS_dyn))
data_micro1 <- data_micro1[complete.cases(data_micro1$CBV_abs), ]
data_micro2 <- data_micro2[complete.cases(data_micro2$CBV_abs), ]
data_micro3 <- data_micro3[complete.cases(data_micro3$CBV_abs), ]
data_micro4 <- data_micro4[complete.cases(data_micro4$CBV_abs), ]
data_micro5 <- data_micro5[complete.cases(data_micro5$CBV_abs), ] #praticamente vuoti dal 5 al 7
data_micro6 <- data_micro6[complete.cases(data_micro6$CBV_abs), ]
data_micro7 <- data_micro7[complete.cases(data_micro7$CBV_abs), ]
