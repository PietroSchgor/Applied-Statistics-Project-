any(is.na(dataset))
colSums(is.na(dataset))
#LMM
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^2
x2 <- dataset$`Hb base`
dataset$Name <- as.factor (dataset$Name)
eps <- dataset$paz
meas <- dataset$meas
mod <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
sigma2_eps <- as.numeric(get_variance_residual(mod))
sigma2_eps
sigma2_b <- as.numeric(get_variance_random(mod))
sigma2_b
PVRE <- sigma2_b/(sigma2_b+sigma2_eps)
PVRE # very high PVRE!!!
mod <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
sigma2_eps <- as.numeric(get_variance_residual(mod))
#### LIBRERIE ####
setwd("/Users/giuliasteiner/Desktop/APPLIED STAT /progetto")
setwd("C:/Users/pfili/OneDrive - Politecnico di Milano/progetto applied/PROGETTO DEF/EMOGLOBINA")
library(car)
# for lasso regression
library(glmnet)
library(car)
# for lasso regression
library(glmnet)
library(sp)           ## Data management
library(lattice)      ## Data management
library(readxl)
library(lme4)
library(ggplot2)
library(insight)
library(nlme) #
#data <- read.delim("dataset_filled_bmi.txt")
dataset <- read_excel("PatioAlbi.xlsx")
#dataset <- merge(x=data, y=dataset , by.x = 1, by.y = 1, all=FALSE,  )
str(dataset)
dim(dataset)
# rimuovo le colonne che non sono necessarie
dataset <- dataset[ , c( "Name", "dose alla fraz mim", "Hb base", "Hb" )]
str(dataset)
dim(dataset)
# creo una variabile misurazione
n <- dim(dataset)[1]
meas <- rep(0, n)
for (i in 1:n){
if (dataset[i, 2]==0) k = 0
else k = k +1
meas[i] <- k
}
dataset$meas <- meas
# aggiugo variabile pazienti effettivi
paz <- rep(0, n)
k = 0
for (i in 1:n){
if (dataset[i, 2]==0)
k = k+1
paz[i] <- k
}
dataset$paz <- paz
xy1 <- xyplot(Hb ~ `dose alla fraz mim`,
groups = paz,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "dose",
ylab = "var Hb",
grid = "h")
xy1 <- xyplot(Hb ~ meas,
groups = paz,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "misurazione",
ylab = "var Hb",
grid = "h")
# rimozione dello stato iniziale
dataset <- dataset[-which(dataset$`dose alla fraz mim` == 0), ]
dim(dataset)
# rimozione dei valori di hb_base <1
dataset <- dataset[-which(dataset$`Hb base` < 1), ]
dim(dataset)
#variazione con segno di Hb, ossia traslo di 100 in negativo
dataset$Hb <- dataset$Hb - 100
# controllo NA
any(is.na(dataset))
colSums(is.na(dataset))
#LMM
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^2
x2 <- dataset$`Hb base`
dataset$Name <- as.factor (dataset$Name)
eps <- dataset$paz
meas <- dataset$meas
mod <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
sigma2_eps <- as.numeric(get_variance_residual(mod))
y
sigma2_eps <- as.numeric(get_variance_residual(mod))
sigma2_eps <- as.numeric(get_variance_residual(mod))
sigma2_eps
sigma2_b <- as.numeric(get_variance_random(mod))
sigma2_b
PVRE <- sigma2_b/(sigma2_b+sigma2_eps)
PVRE # very high PVRE!!!
summary(mod)
residui <- resid(mod)
mse <- mean(residui^2)
sqrt(mse)
#Devo controllare omoschedasticità
library(ggplot2)
ggplot(data.frame(predetti = predict(mod), residui = residui), aes(x = predetti, y = residui)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(x = "Valori Predetti", y = "Residui") +
ggtitle("Grafico dei Residui per Valutare l'Omoschedasticità")
######PROVO ALTRE POTENZE
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
mod2 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod2)
residui2 <- resid(mod2)
mse2 <- mean(residui2^2)
sqrt(mse2)
x1 <- dataset$`dose alla fraz mim`
mod3 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod3)
residui3 <- resid(mod3)
mse3 <- mean(residui3^2)
sqrt(mse3)
x1 <- (dataset$`dose alla fraz mim`)^(3/2)
mod4 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod4)
residui4 <- resid(mod4)
mse4 <- mean(residui4^2)
sqrt(mse4)
#PROVO con prodotto misto
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod5 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod5)
residui5<- resid(mod5)
mse5 <- mean(residui5^2)
sqrt(mse5)
AIC_model1 <- AIC(mod)
AIC_model2 <- AIC(mod2)
AIC_model3 <- AIC(mod3)
AIC_model4 <- AIC(mod4)
AIC_model5 <- AIC(mod5)
# Akaike tiene conto della massima vcerosimiglianza e del numero dei parametri
#−2×log-verosimiglianza massima+2×numero di parametri del modello
print(AIC_model1)
print(AIC_model2)
print(AIC_model3)
print(AIC_model4)
print(AIC_model5) #migliore(se lascio la dose lineare migliora mse ma peggiora AIC (di pochissimo))
if (AIC_model1 < AIC_model2 && AIC_model1 < AIC_model3) {
print("Il primo modello è il migliore.")
} else if (AIC_model2 < AIC_model3){
print("Il secondo modello è il migliore.")
} else {
print("Il terzo modello è il migliore")
}
summary(mod3)
#PROVO con prodotto misto
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod5 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod5)
residui5<- resid(mod5)
mse5 <- mean(residui5^2)
sqrt(mse5)
AIC_model1 <- AIC(mod)
AIC_model2 <- AIC(mod2)
AIC_model3 <- AIC(mod3)
AIC_model4 <- AIC(mod4)
AIC_model5 <- AIC(mod5)
# Akaike tiene conto della massima vcerosimiglianza e del numero dei parametri
#−2×log-verosimiglianza massima+2×numero di parametri del modello
print(AIC_model1)
print(AIC_model2)
print(AIC_model3)
print(AIC_model4)
print(AIC_model5) #migliore(se lascio la dose lineare migliora mse ma peggiora AIC (di pochissimo))
if (AIC_model1 < AIC_model2 && AIC_model1 < AIC_model3) {
print("Il primo modello è il migliore.")
} else if (AIC_model2 < AIC_model3){
print("Il secondo modello è il migliore.")
} else {
print("Il terzo modello è il migliore")
}
##residui eteroschedastici---------
library(nlmeU)
library(corrplot)
library(nlme)
library(lattice)
library(plot.matrix)
library(lme4)
library(insight)
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod6 <- lme(y ~ x1 + x2,
random = ~ 1 + meas| eps,
data = dataset)
summary(mod6)
residui <- resid(mod6)
mse <- mean(residui^2)
sqrt(mse)
mod7 <- update(mod6,
weights = varIdent(form = ~ meas),
data = dataset)
summary(mod7)
residui7<- resid(mod7)
mse7 <- mean(residui7^2)
sqrt(mse7)
AIC_model7<-AIC(mod7)
mod8<- update(mod6,
weights = varPower(form = ~ meas),
data = dataset)
##residui eteroschedastici---------
library(nlmeU)
install.packages("nlmeU")
install.packages("corrplot")
library(readxl)
library(lme4)
library(nlme)
library(corrplot)
library(lattice)
library(plot.matrix)
library(nlmeU)
library(insight)
dataset <- read_excel("PatioAlbi.xlsx")
summary(dataset)
dim(dataset)
dataset$Name<-factor(dataset$Name)
# rimuovo le colonne che non sono necessarie
dataset <- dataset[ , c( "Name", "BMI", "dose alla fraz mim", "Hb base", "Hb" )]
summary(dataset)
dim(dataset)
# rimozione dello stato iniziale
dataset <- dataset[-which(dataset$`dose alla fraz mim` == 0), ]
dim(dataset)
dataset <- dataset[-which(dataset$`dose alla fraz mim` < 2.65), ]
dim(dataset)
# rimozione dei valori di hb_base <1
dataset <- dataset[-which(dataset$`Hb base` < 1), ]
dim(dataset)
#variazione con segno di Hb, ossia traslo di 100 in negativo
dataset$Hb <- dataset$Hb - 100
# controllo NA
any(is.na(dataset))
colSums(is.na(dataset))
#tolgo righe senza BMI
dataset <- dataset[-which(is.na(dataset$BMI)),]
# controllo NA
any(is.na(dataset))
colSums(is.na(dataset))
###########################LMM
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^2
x2 <- dataset$`Hb base`
eps <- dataset$Name
mod <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod)
residui <- resid(mod)
mse <- mean(residui^2)
sqrt(mse)
#Devo controllare omoschedasticità
library(ggplot2)
ggplot(data.frame(predetti = predict(mod), residui = residui), aes(x = predetti, y = residui)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(x = "Valori Predetti", y = "Residui") +
ggtitle("Grafico dei Residui per Valutare l'Omoschedasticità")
######PROVO ALTRE POTENZE
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
mod2 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod2)
residui2 <- resid(mod2)
mse2 <- mean(residui2^2)
sqrt(mse2)
x1 <- dataset$`dose alla fraz mim`
mod3 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod3)
residui3 <- resid(mod3)
mse3 <- mean(residui3^2)
sqrt(mse3)
x1 <- (dataset$`dose alla fraz mim`)^(3/2)
mod4 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod4)
residui4 <- resid(mod4)
mse4 <- mean(residui4^2)
sqrt(mse4)
#PROVO con prodotto misto
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod5 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod5)
residui5<- resid(mod5)
mse5 <- mean(residui5^2)
sqrt(mse5)
#using best NLS coefficients
x1 <- (dataset$`dose alla fraz mim`)^(2/7)
setwd("~/Library/CloudStorage/OneDrive-PolitecnicodiMilano/progetto apllied/effect of ionizing radiations/EMOGLOBINA")
library(car)
# for lasso regression
library(glmnet)
library(sp)           ## Data management
library(lattice)      ## Data management
library(readxl)
library(lme4)
library(ggplot2)
library(insight)
library(nlme) #
#data <- read.delim("dataset_filled_bmi.txt")
dataset <- read_excel("PatioAlbi.xlsx")
#dataset <- merge(x=data, y=dataset , by.x = 1, by.y = 1, all=FALSE,  )
str(dataset)
dim(dataset)
# rimuovo le colonne che non sono necessarie
dataset <- dataset[ , c( "Name", "dose alla fraz mim", "Hb base", "Hb" )]
str(dataset)
dim(dataset)
# creo una variabile misurazione
n <- dim(dataset)[1]
meas <- rep(0, n)
for (i in 1:n){
if (dataset[i, 2]==0) k = 0
else k = k +1
meas[i] <- k
}
dataset$meas <- meas
# aggiugo variabile pazienti effettivi
paz <- rep(0, n)
k = 0
for (i in 1:n){
if (dataset[i, 2]==0)
k = k+1
paz[i] <- k
}
dataset$paz <- paz
xy1 <- xyplot(Hb ~ `dose alla fraz mim`,
groups = paz,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "dose",
ylab = "var Hb",
grid = "h")
xy1 <- xyplot(Hb ~ meas,
groups = paz,
data = dataset,
type = "l", lty = 1)
update(xy1, xlab = "misurazione",
ylab = "var Hb",
grid = "h")
# rimozione dello stato iniziale
dataset <- dataset[-which(dataset$`dose alla fraz mim` == 0), ]
dim(dataset)
# rimozione dei valori di hb_base <1
dataset <- dataset[-which(dataset$`Hb base` < 1), ]
dim(dataset)
#variazione con segno di Hb, ossia traslo di 100 in negativo
dataset$Hb <- dataset$Hb - 100
# controllo NA
any(is.na(dataset))
colSums(is.na(dataset))
#LMM
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^2
x2 <- dataset$`Hb base`
dataset$Name <- as.factor (dataset$Name)
eps <- dataset$paz
meas <- dataset$meas
mod <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
sigma2_eps <- as.numeric(get_variance_residual(mod))
sigma2_eps
sigma2_b <- as.numeric(get_variance_random(mod))
sigma2_b
PVRE <- sigma2_b/(sigma2_b+sigma2_eps)
PVRE # very high PVRE!!!
summary(mod)
residui <- resid(mod)
mse <- mean(residui^2)
sqrt(mse)
#Devo controllare omoschedasticità
library(ggplot2)
ggplot(data.frame(predetti = predict(mod), residui = residui), aes(x = predetti, y = residui)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(x = "Valori Predetti", y = "Residui") +
ggtitle("Grafico dei Residui per Valutare l'Omoschedasticità")
######PROVO ALTRE POTENZE
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
mod2 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod2)
residui2 <- resid(mod2)
mse2 <- mean(residui2^2)
sqrt(mse2)
x1 <- dataset$`dose alla fraz mim`
mod3 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod3)
residui3 <- resid(mod3)
mse3 <- mean(residui3^2)
sqrt(mse3)
x1 <- (dataset$`dose alla fraz mim`)^(3/2)
mod4 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod4)
residui4 <- resid(mod4)
mse4 <- mean(residui4^2)
sqrt(mse4)
#PROVO con prodotto misto
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod5 <- lmer(y ~ x1 + x2  +  (1|eps),
data = dataset)
summary(mod5)
residui5<- resid(mod5)
mse5 <- mean(residui5^2)
sqrt(mse5)
AIC_model1 <- AIC(mod)
AIC_model2 <- AIC(mod2)
AIC_model3 <- AIC(mod3)
AIC_model4 <- AIC(mod4)
AIC_model5 <- AIC(mod5)
# Akaike tiene conto della massima vcerosimiglianza e del numero dei parametri
#−2×log-verosimiglianza massima+2×numero di parametri del modello
print(AIC_model1)
print(AIC_model2)
print(AIC_model3)
print(AIC_model4)
print(AIC_model5) #migliore(se lascio la dose lineare migliora mse ma peggiora AIC (di pochissimo))
if (AIC_model1 < AIC_model2 && AIC_model1 < AIC_model3) {
print("Il primo modello è il migliore.")
} else if (AIC_model2 < AIC_model3){
print("Il secondo modello è il migliore.")
} else {
print("Il terzo modello è il migliore")
}
##residui eteroschedastici---------
library(nlmeU)
library(corrplot)
library(nlme)
library(lattice)
library(plot.matrix)
library(lme4)
library(insight)
y <- dataset$Hb
x1 <- (dataset$`dose alla fraz mim`)^(1/2)
x2 <- (dataset$`dose alla fraz mim`)*(dataset$`Hb base`)
mod6 <- lme(y ~ x1 + x2,
random = ~ 1 + meas| eps,
data = dataset)
summary(mod6)
residui <- resid(mod6)
mse <- mean(residui^2)
sqrt(mse)
mod7 <- update(mod6,
weights = varIdent(form = ~ meas),
data = dataset)
summary(mod7)
residui7<- resid(mod7)
mse7 <- mean(residui7^2)
sqrt(mse7)
AIC_model7<-AIC(mod7)
mod8<- update(mod6,
weights = varPower(form = ~ meas),
data = dataset)
mod8<- update(mod6,
weights = varPower(form = ~ meas),
data = dataset)
summary(mod8)
residui8<- resid(mod8)
mse8 <- mean(residui8^2)
sqrt(mse8)
AIC_model8<- AIC(mod8)
# diminuiscono sia AIC che MSE -> mse molto più piccolo rispetto al modello con varIdent
anova(mod8, mod6) #pvalue abbastanza basso (preferisco mod8)
mod9 <- update (mod8, correlation = corCompSymm(form = ~1|eps), data = dataset)
residui9<- resid(mod9)
mod9 <- update (mod8, correlation = corCompSymm(form = ~1|eps), data = dataset)
summary(mod9)
residui9<- resid(mod9)
mse9 <- mean(residui9^2)
sqrt(mse9)
AIC_model9<- AIC(mod9)
anova(mod9, mod8)
fv <- as.factor(dataset$meas)
plot(mod8)
plot(mod8, col = col1)
plot(mod8, resid(., type = "response") ~ meas)
bwplot(resid(mod8) ~ fv, pch = "|", data = dataset)
boxplot(mod1$residuals ~ dataset$paz, col=colori,
xlab='patients', ylab='Residuals', main ='Distribution of residuals across patients')
boxplot(mod6$residuals ~ dataset$paz, col=colori,
xlab='patients', ylab='Residuals', main ='Distribution of residuals across patients')  ## --> informative!
boxplot(mod8$residuals ~ dataset$paz, col=colori,
xlab='patients', ylab='Residuals', main ='Distribution of residuals across patients')  ## --> informative!
